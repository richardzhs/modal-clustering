---
title: "More Experiments on Gaussian Mixture Model"
output:
  html_document:
    df_print: paged
    toc: yes
  html_notebook:
    theme: united
    toc: yes
---
## Introduction
Here we want to do several experiments on Gaussian mixture model. For the sake of simplicity, we just use the oil data for now.  
(1) First want to fit the gaussian mixture model on oil data based on the known labels. Then we perform optimization on the mixture model and cluster the modes.  
(2) We will take a sample from the fitted Gaussian mixture model. Then apply KDE method and mean-shift algorithm on this sample and see the results.  
(3) We want to testify the "fnscale" parameter in the optimization and see whether it affects the optimization result. Based on the documentation,   
"An overall scaling to be applied to the value of fn and gr during optimization. If negative, turns the problem into a maximization problem. Optimization is performed on fn(par)/fnscale"  
Therefore, it is rescaling the function by a constant, which should make no difference to the optimizing result in principle.

## Loading Library and Packages
```{r}
library(meanShiftR)
library(mvtnorm)
library(here)

dir <- here()
dir.sep <- "/"
echo <- T
source(paste(here("function_packages"), "kernel-density-estimation-functions.R", sep = dir.sep))
source(paste(here("function_packages"), "gaussian-mixture-model-functions.R", sep = dir.sep))
source(paste(here("function_packages"), "density-optimizing-functions.R", sep = dir.sep))
```


## Importing Data

### Olive Oil dataset
Olive oil data has 572 observations with 8 variables and 9 distinct groups.

```{r}
data.filename <- "olive.R"
data.pathname <- paste(here("data"), data.filename, sep = dir.sep)
source(data.pathname)
```

```{r}
oil.data <- X # save the matrix as 'oil.data'
oil.group.id <- group.id # save the id as 'oil.group.id'
```

## Gaussian Mixture Model

### Fitting Model

```{r}
mix.par.oil <- fit.gmm(oil.data, oil.group.id)
mix.dens.oil <- make.dgmm(mix.par.oil)
```

### Numerical Optimization

```{r}
optim.out.filename <- "/optimizing_result/oil-mixture-density-optima.R"
optim.out.pathname <- paste(dir, optim.out.filename, sep = "\\")

control <- list("maxit" = 10000, "fnscale" = -1e-20)

gradient <- make.dgmm.gradient(mix.par.oil)
optimize.density(oil.data, mix.dens.oil, optim.out.pathname, gradient = gradient, control = control, echo = F)
```


```{r}
optima <- read.optim(oil.data, optim.out.pathname)
```
#### Cluster Local Maxima

```{r}
clust <- hclust(dist(optima), method = "ward.D2")
clust$height
```
There are 8 "large" merge distances at the end, which suggests that there are 9 groups. This is consistent with what we expect.


## Kernel Density Estimation
Now we try to take a sample from the mixture model and fit the KDE on this sample. Then we run the numerical optimization on the KDE to find the local maximums. We also want to test different "fnscale" to see the difference.

### Sampling from Mixture Model

```{r}
set.seed(1234)
mix.sample.oil <- rgmm(n = 572, mixture.par = mix.par.oil)
```

### Fit KDE on Mixture Sample

```{r}
sphered.mix.oil <- sphere(mix.sample.oil$X)
trial.hs <- c(0.05, 0.1, 0.15, 0.2, 0.3, 0.4, 0.6, 0.8, 1.0, 1.5, 2.0)
cv.search.out <- cv.search(sphered.mix.oil, trial.hs)
h.mix.oil <- cv.search.out$opt.smopar
```

```{r}
density.oil.sample <- make.gaussian.kernel.density.estimate(sphered.mix.oil, h.mix.oil)
```

### Numerical Optimization


#### *fnscale = -1
```{r}
optim.out.filename <- "/optimizing_result/olive-kde-oil-mixture-sample-optima-scale=-1.R"
optim.out.pathname <- paste(here(), optim.out.filename, sep = "\\")

gradient <- make.kde.gradient(X.train = sphered.mix.oil, h = h.mix.oil)
control <- control <- list("maxit" = 10000, "fnscale" = -1)

optimize.density(sphered.mix.oil, density.oil.sample, optim.out.pathname, gradient = gradient, control = control, echo = T)
```

```{r}
optima <- read.optim(sphered.mix.oil, optim.out.pathname)
```

```{r}
clust <- hclust(dist(optima), method = "ward.D2")
clust$height
```


#### *fnscale = -1
```{r}
optim.out.filename <- "/optimizing_result/olive-kde-oil-mixture-sample-optima-scale=-10.R"
optim.out.pathname <- paste(here(), optim.out.filename, sep = "\\")

gradient <- make.kde.gradient(X.train = sphered.mix.oil, h = h.mix.oil)
control <- control <- list("maxit" = 10000, "fnscale" = -10)

optimize.density(sphered.mix.oil, density.oil.sample, optim.out.pathname, gradient = gradient, control = control, echo = F)
```

```{r}
optima <- read.optim(sphered.mix.oil, optim.out.pathname)
```

```{r}
clust <- hclust(dist(optima), method = "ward.D2")
clust$height
```
There is a "jump" at merge 39.

#### *fnscale = -1e-20
```{r}
optim.out.filename <- "/optimizing_result/olive-kde-oil-mixture-sample-optima-scale=-1e-20.R"
optim.out.pathname <- paste(here(), optim.out.filename, sep = "\\")

gradient <- make.kde.gradient(X.train = sphered.mix.oil, h = h.mix.oil)
control <- control <- list("maxit" = 10000, "fnscale" = -1e-20)

optimize.density(sphered.mix.oil, density.oil.sample, optim.out.pathname, gradient = gradient, control = control, echo = F)
```

```{r}
optima <- read.optim(sphered.mix.oil, optim.out.pathname)
```

```{r}
clust <- hclust(dist(optima), method = "ward.D2")
clust$height
```
There is a "jump" at merge 55.

#### *fnscale = -1e-30
```{r}
optim.out.filename <- "/optimizing_result/olive-kde-oil-mixture-sample-optima-scale=-1e-30.R"
optim.out.pathname <- paste(here(), optim.out.filename, sep = "\\")

control <- control <- list("maxit" = 10000, "fnscale" = -1e-30)

optimize.density(sphered.mix.oil, density.oil.sample, optim.out.pathname, gradient = gradient, control = control, echo = F)
```

```{r}
optima <- read.optim(sphered.mix.oil, optim.out.pathname)
```

```{r}
clust <- hclust(dist(optima), method = "ward.D2")
clust$height
```
There are is a "jump" at merge 52.


## Mean-shift
Now we try to run mean-shift algorithm on the mixture sample.

```{r}
ms <- meanShift(sphered.mix.oil, bandwidth = rep(h.mix.oil, 8), iterations = 1000000)
```

```{r}
max(ms$assignment)
```
There are 162 groups after applying meanshift algorithm which is consistent with the result of KDE when fnscale = -1, i.e. the original scale.  

How about different bandwidth instead of the one from cross validation? Maybe it was just a bad bandwidth selection. So here we try to adjust the bandwidth h so that it actually gives us 9 groups. By trying out, it shows that we can set h=0.871.
```{r}
ms <- meanShift(sphered.mix.oil, bandwidth = rep(0.871, 8), iterations = 1000000)
```

```{r}
max(ms$assignment)
```
Let's see the corresponding assignment:
```{r}
c(ms$assignment)
```
Here are the true labels:
```{r}
mix.sample.oil$group.id
```
Apparently the corresponding assignment does not reference to the true labels.

## Discussion
First, the result from optimizing the Gaussian Mixture Model shows that there are 9 "distinct" modes which is equal to the true number of groups.  
Second, by sampling from this mixture model, our KDE estimate or mean-shift algorithm should also give us 9 "distinct" modes if it behaves well. However, this is not the case and it still overestimates the number of modes. Even by increasing the bandwidth to match the true number of modes, it does not produce the same modes.  
Third, by changing the "fnscale" parameter, we got different jumps at the merge distances. This suggests that "fnscale" does change the optimizing result on KDE. Since "fnscale" only rescales the function by a constant, the converging locations should be the same. One explanation might be because there are lots of little "wiggles" in the function that is within the tolerance for convergence. Then by rescaling the function, the wiggles gets "amplified" such that these turn to be the local maximums. Hence, it changes the converging locations for some points. But still, I am not sure exactly why.